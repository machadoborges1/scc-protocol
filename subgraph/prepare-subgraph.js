const fs = require('fs');
const path = require('path');
const { ethers } = require('ethers');

// Define os caminhos para os arquivos necessários.
const projectRoot = path.join(__dirname, '..');
const templatePath = path.join(__dirname, 'subgraph.template.yaml');
const outputPath = path.join(__dirname, 'subgraph.yaml');
const artifactPath = path.join(projectRoot, 'contracts', 'broadcast', 'Deploy.s.sol', '31337', 'run-latest.json');
const generatedDir = path.join(__dirname, 'src', 'generated');
const addressesOutputPath = path.join(generatedDir, 'addresses.ts');

async function main() {
    console.log('Lendo artefatos do deploy...');

    let artifact;
    try {
        const artifactContent = fs.readFileSync(artifactPath, 'utf8');
        artifact = JSON.parse(artifactContent);
    } catch (error) {
        console.error(`Erro: Não foi possível ler ou parsear o arquivo de artefatos em ${artifactPath}`);
        console.error('Certifique-se de que os contratos foram deployados com `forge script`.');
        console.error(error);
        process.exit(1);
    }

    console.log('Extraindo endereços dos contratos e bloco inicial...');

    const contractCreations = artifact.transactions.filter(tx => tx.transactionType === 'CREATE');

    const getAddress = (contractName) => {
        const tx = contractCreations.find(c => c.contractName === contractName);
        if (!tx) {
            console.error(`Erro: Não foi possível encontrar o contrato "${contractName}" nos artefatos de deploy.`);
            process.exit(1);
        }
        return tx.contractAddress;
    };

    const getStartBlock = () => {
        const vaultFactoryTx = artifact.transactions.find(tx => tx.contractName === 'VaultFactory' && tx.transactionType === 'CREATE');
        const receipt = artifact.receipts.find(r => r.transactionHash === vaultFactoryTx.hash);
        return parseInt(receipt.blockNumber, 16);
    };

    const addresses = {
        VAULT_FACTORY_ADDRESS: getAddress('VaultFactory'),
        ORACLE_MANAGER_ADDRESS: getAddress('OracleManager'),
        LIQUIDATION_MANAGER_ADDRESS: getAddress('LiquidationManager'),
        STAKING_POOL_ADDRESS: getAddress('StakingPool'),
        SCC_GOVERNOR_ADDRESS: getAddress('SCC_Governor'),
        SCC_PARAMETERS_ADDRESS: getAddress('SCC_Parameters'),
    };
    console.log('Using addresses:', addresses);
    const startBlock = getStartBlock();

    console.log(`  -> Bloco Inicial: ${startBlock}`);
    console.log(`  -> Endereços dos Contratos Principais Extraídos.`);

    // Etapa profissional: Buscar endereços de tokens dinamicamente
    console.log('Buscando endereços dos tokens SCC_USD e SCC_GOV dinamicamente...');
    const provider = new ethers.JsonRpcProvider('http://localhost:8545');
    
    const vaultFactoryContract = new ethers.Contract(addresses.VAULT_FACTORY_ADDRESS, ['function sccUsdToken() view returns (address)'], provider);
    const sccUsdAddress = await vaultFactoryContract.sccUsdToken();

    const stakingPoolContract = new ethers.Contract(addresses.STAKING_POOL_ADDRESS, ['function stakingToken() view returns (address)'], provider);
    const sccGovAddress = await stakingPoolContract.stakingToken();

    console.log(`  -> Endereço SCC_USD: ${sccUsdAddress}`);
    console.log(`  -> Endereço SCC_GOV: ${sccGovAddress}`);

    // Gera o arquivo de endereços para os mapeamentos
    if (!fs.existsSync(generatedDir)) {
        fs.mkdirSync(generatedDir, { recursive: true });
    }
    const addressesFileContent = `
        // THIS IS AN AUTOGENERATED FILE. DO NOT EDIT DIRECTLY.
        import { Address } from '@graphprotocol/graph-ts';

        export const SCC_USD_ADDRESS = Address.fromString('${sccUsdAddress}');
        export const SCC_GOV_ADDRESS = Address.fromString('${sccGovAddress}');
    `;
    fs.writeFileSync(addressesOutputPath, addressesFileContent.trim(), 'utf8');
    console.log(`✅ Arquivo de endereços gerado em ${addressesOutputPath}`);


    console.log('Substituindo placeholders no template...');
    let templateContent = fs.readFileSync(templatePath, 'utf8');
    let outputContent = templateContent.replace(/{{START_BLOCK}}/g, startBlock);
    for (const [key, value] of Object.entries(addresses)) {
        const placeholder = new RegExp(`{{${key}}}`, 'g');
        outputContent = outputContent.replace(placeholder, value);
    }

    fs.writeFileSync(outputPath, outputContent, 'utf8');
    console.log(`✅ Arquivo ${outputPath} gerado com sucesso!`);
}

main().catch(error => {
    console.error('Ocorreu um erro inesperado durante a execução do script:');
    console.error(error);
    process.exit(1);
});
